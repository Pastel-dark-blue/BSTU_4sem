--	1 найти перевозки, которые идут по маршруту, в названии которых содержится слово "Минск" или "Гомель" и вывести коды водителей на этих перевозках
-- На основе таблиц "Маршруты", "Перевозки", "Водители на перевозках"
--	Примечание: использовать в секции WHERE предикат IN c некоррелированным подзапросом к таблице Маршруты
select distinct Код_водителя
	from [Водители на перевозках], Перевозки
	where [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
	and
	Перевозки.Код_маршрута in
	(select Код_маршрута
		from Маршруты
			where Название like '%минск%'
			or Название like '%гомель%');

--	2 Переписать запрос пункта 1 таким образом, чтобы тот же подзапрос был записан в конструкции INNER JOIN секции FROM внешнего запроса. При этом результат выполнения запроса должен быть аналогичным результату исходного запроса. 
select distinct Код_водителя
	from [Водители на перевозках] inner join Перевозки
	on [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
	and
	Перевозки.Код_маршрута in
	(select Код_маршрута
		from Маршруты
			where Название like '%минск%'
			or Название like '%гомель%');

--	3 Переписать запрос, реализующий 1 пункт без использования подзапроса. Примечание: использовать соединение INNER JOIN трех таблиц. 
select distinct Код_водителя
	from [Водители на перевозках] inner join Перевозки
	on [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
	inner join Маршруты
		on Перевозки.Код_маршрута = Маршруты.Код_маршрута
		and (Название like '%минск%'
			or Название like '%гомель%');

--	4 Для каждого водителя найти код перевозки, за которую он(а) получил(а) наибольшую оплату 
-- При этом результат следует отсортировать в порядке убывания вместимости. Примечание: использовать коррелируемый подзапрос c секциями TOP и ORDER BY. 
select *
		from [Водители на перевозках] as a
		where a.Код_перевозки = (
			select top(1) Код_перевозки
			from [Водители на перевозках] as b
			where a.Код_водителя = b.Код_водителя
			order by b.[Оплата, USD] desc
		);

--	5 сформировать список водителей, ни разу не бывавших на перевозках
-- Примечание: использовать предикат EXISTS и коррелированный подзапрос. 
select *
	from Водители
	where not exists(
		select *
			from [Водители на перевозках]
			where [Водители на перевозках].Код_водителя = Водители.Код_водителя)

--	6 на основе таблиц [Водители на перевозках] и Перевозки сформировать строку, содержащую средние значения оплаты за маршруты с кодом 1, 2 и 3
-- Примечание: использовать три некоррелированных подзапроса в списке SELECT; в подзапросах применить агрегатные функции AVG. 
select top(1)
	(select avg([Оплата, USD]) 
		from [Водители на перевозках], Перевозки
			where [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
			and 
			Перевозки.Код_маршрута = 1) as [Маршрут 1],
	(select avg([Оплата, USD]) 
		from [Водители на перевозках], Перевозки
			where [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
			and 
			Перевозки.Код_маршрута = 2) as [Маршрут 2],
	(select avg([Оплата, USD]) 
		from [Водители на перевозках], Перевозки
			where [Водители на перевозках].Код_перевозки = Перевозки.Код_перевозки
			and 
			Перевозки.Код_маршрута = 3) as [Маршрут 3];

--	7 выбрать маршрут(ы) с наибольшей дальностью
-- Разработать SELECT-запрос, демонстрирующий принцип применения ALL совместно с подзапросом.
select *
	from Маршруты
		where [Дальность, км] >=all(
			select [Дальность, км] 
				from Маршруты 
		);

--	8 выбрать маршруты, дальность которых превышает хотя бы один маршрут, содержащем "Минск" в своем названии
-- Разработать SELECT-запрос, демонстрирующий принцип применения ANY совместно с подзапросом.
select *
	from Маршруты
		where [Дальность, км] >any(
			select [Дальность, км] 
				from Маршруты
				where Название like '%Минск%'
		);

